Использование бинарных и текстовых файлов. Использование бинарного режима вынуждает программу передавать
данные из памяти в файл и обратно без каких либо преобразований. Использование файлов в текстовом режиме
выполняет различного рода преобразования, в том числе обработку признака конца строки, который кодируется комбинацией двух символов /n, /r(Переход строки и возврат коретки). В других системах новая строка может 
быть представлена только символом возрата коретки, либо только символом перехода на новую строку. Так же может
вызвать проблемы с бинарными файлами, так как байт в середине значения типа double может иметь тот же видовый шаблон, что и ASCII код другого символа. Чтобы сохранить данные в бинарной форме, необходимо пользоваться методом write() важной особенностью которого является то, что он требует приведения адреса объекта указателем на тип char. Для корректной записи считывания данных в бинарном виде необходимо использовать оператор sizeof возвращающий количество байт, выделяемых для типа или объекта типа. Так как в этом случае сохраняются только данные но не методы. При наличии виртуальных методов будет скопирован скрытый указатель на виртуальную таблицу адресов вызываемых функций. А при следующем запуске программы, эти данные будут не актуальны. Метод read используется для восстановления данных, которые были записаны с помощью write(). Часто возникает проблема с объектом string, так как он в действительности не содержит в себе строку. Вместо этого он содержит в себе указатель, где храниться строка, так что если копировать данные string в файл, то будут скопированы не данные строки, а адрес области ее хранения.
	
						Произвольный доступ
Класс fstream наследует два буфера(для ввода и вывода данных) и синхронизирует управление этими двумя буферами. 
Класс fstream представляет собой специализаци. fbasic_stream, одновременно позволяя перемещать указатель ввода и вывода соответсвующих буфера. Класс fstream предлагает два методы для перемещения по файлам. seekg() перемещает указатель который предназначен для считывания данных. seekp перемещает указатель записи данных в файл. Методы являются шаблонными. Два прототипа метода seekg позволяет указать как смещение в байтах, так и позицию. Позиция смещения задается seekdir представленной 3 альтернативными вариантами. Для проверки текущей позиции используют метод tellg, tellp.

						STL
Стандартная библиотека шаблонов содержит контейнеры, итераторы, алгоритмы, и объекты функций. Контейнер - это структура данных, похожая на массив, которая может хранить набор значений разных типов данных. Контейнеры можно разделить на 3 категории: последовательные, ассоциативные, контейнеры - адаптеры. Алгоритмы используются для решения определенных задач(сортировки элементов контейнера, поиска конкретного элемента в контейнера, перемешиывание элементов) Итераторы - это объекты, позволяющие перемещаться внутри контейнера подобно тому, как указатель перемещается по массиву. Итераторы являются обобщениями указателей.
						Объекты функций
Это объекты, которые ведут себя подобно функциям, они могут быть объктами класса или указателями на функции. Библиотека STL не является примером ООП. В библиотеке STL используется другая технология программировния - обобщенное программирование.
						Шаблонный класс вектор
Вектор соответсвуте массиву а не математическому вектору. Вектор - набор однотипных значений, к которым можно обращаться в произвольном порядке. При использовании вектора можно создать один объект на основании другого, использовать операцию [] для доступа к отдельным элементам. Шаблон вектор используется для дилигирования динамического выделения памяти на библиотеку STL, так же при создании вектора можно указать количество создаваемых элементов. Перегрузка оператора [] позволяет обращаться к переменным вектора, используя нотацию массива, но работа с любым контейнером через итератор всегда быстрее чем через индекс. Все шаблоны контейнера библиотеки STL принимают необязательный аргемент, который указавает какой объект распределитель будет использоваться для управления памятью в создаваемом контейнере. Если опустить значение объекта, то шаблон контейнера по умолчанию будет использовать класс allocator<Type>, который для выделения и освобождения памяти использует new и delete.